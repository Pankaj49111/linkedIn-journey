{
  "post_text": "Data disappeared under load.\nAdding logs made the bug VANISH completely. \ud83d\udc7b\n\nWe had a critical update failure in our Spring Boot service. Intermittent. Only under 500+ requests per second. Postgres transactions were committing, but data was simply MISSING later. IMPOSSIBLE.\n\nI instrumented Hibernate tracing. I checked slow queries. I added DEBUG logging to the controller layer. Every time, the failure rate dropped to zero. We were convinced it was a ghost.\n\nThe inflection point: I removed the logging, but left the logger initialization code in place. The bug returned IMMEDIATELY.\n\nI finally looked at resource utilization, not logic. The logging library initialization had introduced a 5ms delay on thread startup. That small delay was ENOUGH to prevent a massive connection starve-out event in HikariCP, which was interacting BADLY with an overly AGGRESSIVE Spring transaction timeout default. It was a timing window, not a logic error.\n\nThe Confession: I wasted 48 hours chasing JPA entity state when the REAL culprit was a default configuration I assumed was safe. I should have PROFILED first.\n\nThe Moral \ud83d\udc47\nThe cost of solving a Heisenbug is measured in humility and lost assumptions.\n\nWhich default framework setting burned you the most recently?\n\n#backend #engineering #software #java",
  "lesson_extracted": "Never assume logging overhead is benign; sometimes it masks deep-seated resource contention or race conditions by changing system timing."
}