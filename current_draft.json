{
  "post_text": "We trusted the partition key. That trust failed instantly.\n\nI was confident in our scaling strategy for Payment Reconciliation. We partitioned our stream strictly by `UserID`, guaranteeing FIFO ordering for every user ledger. This was foundational.\n\nWhen the high-volume weekend batch hit, the symptom was subtle chaos. Balances updated, but they flipped between positive and negative numbers erratically. Data looked poisoned.\n\nWe checked consumers; they were fast and idempotent. I assumed a serialization bug or a resource deadlock. But traces showed `BalanceUpdate` events arriving completely out of sequence\u2014a `RefundIssued` hitting the database before the original `ChargeCompleted`. \ud83e\udd2f\n\nThis made no sense. The UserID partition should force sequential processing! I tracked the events upstream.\n\nThe contradiction hit me hard. I thought partitioning solved the problem. Our queue guarantees ordering only if a single producer writes to that partition. We had two distinct microservices\u2014Invoicing and Payouts\u2014writing events using the same UserID key asynchronously. Our ordering guarantee was broken the moment we introduced dual producers. We engineered for consumer safety but forgot producer discipline. \ud83d\udea8\n\n\n\nThe Moral \ud83d\udc47\nDistributed ordering guarantees are about the producer contract, not the consumer assumption.",
  "lesson_extracted": "Distributed ordering guarantees are about the producer contract, not the consumer assumption.",
  "meta_theme": "THE CRASH \ud83d\udea8",
  "meta_tech": "Event Ordering"
}