{
  "post_text": "I thought At-Least-Once was cheap. It wasn't.\n\nWe built the payment reconciliation system to handle high volume via Kafka, prioritizing zero message loss. At-Least-Once was the mandate.\n\nFor idempotency, I implemented a simple Redis key check based on the inbound message ID, setting the TTL to 60 minutes. That window felt safe for normal network jitter and retries.\n\nThen came the holiday flash sale. Load instantly spiked 4x.\n\nConsumer group lag shot up to eight figures almost immediately. Redis latency began to choke our processing threads.\n\nWe slowed down hard, but when the consumers finally started catching up, the visible duplication began.\n\nThe messages we processed an hour ago were still sitting in the queue, but their associated Redis idempotency keys had already expired. We delivered the same payment status three times. \ud83e\udd26\n\nThe duration of the backlog defined the necessary TTL, not the network timeout.\n\nWhat this taught me \ud83d\udc47\nIdempotency TTL must exceed the maximum theoretical time required to clear a full, multi-day production backlog, otherwise, 'At-Least-Once' becomes 'At-Most-Thrice.'\n\n#backend #engineering #software #java",
  "lesson_extracted": "Idempotency TTL must exceed the maximum theoretical time required to clear a full, multi-day production backlog, otherwise, 'At-Least-Once' becomes 'At-Most-Thrice.'",
  "meta_theme": "THE CRASH \ud83d\udea8",
  "meta_tech": "At-Least-Once Delivery & Idempotency"
}