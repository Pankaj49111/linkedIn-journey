{
  "post_text": "I\u2019ve built fault-tolerant systems for years. I trust my primitives.\nWe enabled strict client-side retries on our new payment API. I assumed our database-level uniqueness constraint on the core `transaction_id` was sufficient for idempotency. I thought that safeguard was enough to handle transient network errors.\nA major partner launched a massive promotion, spiking traffic five-fold. Soon, customer support calls flooded in. Users were being double-charged, yet our primary ledger records looked perfectly clean.\nWhy are the external payments showing successful duplicates when the internal service successfully rejected the second call? This contradiction made no sense.\nWe traced the logs obsessively. The realization hit hard: We weren't holding the idempotency lock long enough. The external payment provider executed the second request before our own database transaction committed locally. Our constraint protected the final state but failed to protect the transitional payment instruction. We spent the entire weekend manually reconciling 800+ incorrect charges.\n\n\nThe Moral \ud83d\udc47\nThe complexity of distributed state always exceeds the sum of its local parts.",
  "lesson_extracted": "The complexity of distributed state always exceeds the sum of its local parts.",
  "meta_theme": "THE HUMAN ALGORITHM \ud83e\udd1d",
  "meta_tech": "Idempotency"
}